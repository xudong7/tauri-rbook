<script setup lang="ts">
import { ref, onMounted, onUnmounted, watch } from "vue";
import { useRouter } from "vue-router";
import { Window } from "@tauri-apps/api/window";
import { getEpubHtmlWithImages, HtmlWithImages } from "../../api";
import {
  ArrowLeft,
  ArrowRight,
  Minus,
  FullScreen,
  Close,
  Setting,
} from "@element-plus/icons-vue";
import { ElDropdown, ElDropdownItem, ElDropdownMenu } from "element-plus";

const router = useRouter();

// Props
const props = defineProps<{
  initialFilePath?: string;
}>();

const currentContent = ref<string>("");
const leftColumnContent = ref<string>("");
const rightColumnContent = ref<string>("");
const loading = ref<boolean>(false);
const filePath = ref<string>("");
const htmlWithImages = ref<HtmlWithImages | null>(null);
const appWindow = Window.getCurrent();
const lastWindowSize = ref<{ width: number; height: number }>({
  width: 0,
  height: 0,
});
const resizeTimeout = ref<number | null>(null);

// 添加分页相关的响应式变量
const currentPage = ref<number>(0);
const totalPages = ref<number>(0);
const allPages = ref<string[]>([]);

// Function to load a book from a specified path
const loadBookFromPath = async (path: string) => {
  try {
    loading.value = true;
    filePath.value = path;

    // 调用后端API获取HTML和图片
    htmlWithImages.value = await getEpubHtmlWithImages(path);

    // 跳转到第一页
    currentPage.value = 0;

    // 处理HTML内容和图片
    processHtmlContent();

    loading.value = false;
  } catch (error) {
    console.error("Error loading book:", error);
    loading.value = false;
  }
};

// Watch for initialFilePath changes to load book
watch(
  () => props.initialFilePath,
  (newPath) => {
    if (newPath) {
      loadBookFromPath(newPath);
    }
  },
  { immediate: true }
);

// Go back to menu
const goBackToMenu = () => {
  router.push("/");
};

// 设置菜单选项的处理函数，未实现

const GLOBAL_STYLE = `<style>
  html { overflow: hidden!important; margin: 20px; padding: 0; }
  body {
    font-family: 'Noto Serif', 'Times New Roman', serif!important;
    font-size: 18px!important;
    line-height: 1.4!important;
    color: #333!important;
    box-sizing: border-box!important;
  }
  p {
    margin: 1em!important;
    text-indent: 1em!important;
  }
  p.pre {
    margin: 0!important;
  }
  a {
    pointer-events: none!important;
    text-decoration: none!important;
  }
</style>`;

const PAGE_PADDING = 20; // px

// 监听窗口大小变化，以重新布局页面内容
const handleWindowResize = () => {
  // 使用防抖，避免频繁重新计算
  if (resizeTimeout.value !== null) {
    clearTimeout(resizeTimeout.value);
  }

  resizeTimeout.value = window.setTimeout(() => {
    const currentWidth = window.innerWidth;
    const currentHeight = window.innerHeight;

    // 如果窗口大小变化超过一定阈值，则重新计算页面布局
    if (
      Math.abs(currentWidth - lastWindowSize.value.width) > 50 ||
      Math.abs(currentHeight - lastWindowSize.value.height) > 50
    ) {
      lastWindowSize.value = { width: currentWidth, height: currentHeight };

      // 如果当前有内容，则重新分割页面
      if (htmlWithImages.value) {
        processHtmlContent();
      }
    }

    resizeTimeout.value = null;
  }, 300);
};

const onWheel = (e: WheelEvent) => {
  // console.log("wheel event", e.deltaY, currentContent.value);
  if (!currentContent.value) {
    return;
  }
  if (e.deltaY > 0) {
    // console.log("goToNextPage");
    goToNextPage();
  } else if (e.deltaY < 0) {
    // console.log("goToPreviousPage");
    goToPreviousPage();
  }
};

// 组件挂载和卸载时添加/移除窗口大小变化监听
onMounted(() => {
  lastWindowSize.value = {
    width: window.innerWidth,
    height: window.innerHeight,
  };
  window.addEventListener("resize", handleWindowResize);
});

onUnmounted(() => {
  window.removeEventListener("resize", handleWindowResize);
  if (resizeTimeout.value !== null) {
    clearTimeout(resizeTimeout.value);
  }
});

// 处理HTML内容和图片
const processHtmlContent = async () => {
  if (!htmlWithImages.value) return;
  let html = htmlWithImages.value.html_content;
  const images = htmlWithImages.value.images;
  images.forEach((img) => {
    const dataUrl = `data:${img.mime_type};base64,${img.content}`;
    html = html.replace(
      new RegExp(`src=['"]${img.path}['"]`, "g"),
      `src=\"${dataUrl}\"`
    );
  });
  currentContent.value = html;
  await splitContentForTwoColumns(html);
};

// 拆分大型span中的文本
const splitLargeSpanText = (
  spanNode: Node,
  tagName: string,
  pageContainer: HTMLDivElement,
  pageHeight: number,
  currentPageContent: string
): { elements: HTMLElement[]; firstPageContent: string } => {
  // 只处理SPAN节点和文本节点
  if (
    spanNode.nodeName !== "SPAN" &&
    spanNode.nodeName !== "#text" &&
    spanNode.nodeName !== "TEXT"
  ) {
    const wrapper = document.createElement(tagName);
    wrapper.appendChild(spanNode.cloneNode(true));
    return { elements: [wrapper], firstPageContent: currentPageContent };
  }

  // 获取节点的文本内容
  let text = spanNode.textContent || "";

  // 如果文本很短，不需要分割
  if (text.length < 100) {
    const wrapper = document.createElement(tagName);
    wrapper.appendChild(spanNode.cloneNode(true));
    return { elements: [wrapper], firstPageContent: currentPageContent };
  }

  // 用于存储分割后的元素
  const elements: HTMLElement[] = [];
  let remainingText = text;
  let span: HTMLElement;
  let testElement: HTMLElement = document.createElement("div");
  let segmentLength = 50; // 初始分段长度
  let updatedPageContent = currentPageContent;
  let isFirstSegment = true;
  let currentTestLength = 0;

  // 循环拆分文本，直到所有文本都被处理
  while (remainingText.length > 0) {
    // 创建一个新的段落和span元素
    const newElement = document.createElement(tagName);

    if (spanNode.nodeName === "#text" || spanNode.nodeName === "TEXT") {
      // 如果是文本节点，直接添加文本
      let testLength = Math.min(segmentLength, remainingText.length);

      // 尝试增加文本长度，直到页面溢出
      while (testLength < remainingText.length) {
        const testText = remainingText.substring(0, testLength);
        newElement.textContent = testText;

        testElement.innerHTML =
          GLOBAL_STYLE + updatedPageContent + newElement.outerHTML;
        pageContainer.innerHTML = testElement.innerHTML;

        if (pageContainer.clientHeight > pageHeight) {
          // 如果溢出，回退到上一个长度
          if (testLength > segmentLength) {
            testLength =
              testLength -
              Math.max(20, Math.floor((testLength - segmentLength) / 2));
          } else {
            // 即使最小分段也溢出，则取最小值
            testLength = Math.max(10, testLength - 10);
          }
          break;
        }

        // 增加测试长度
        testLength = Math.min(testLength + 50, remainingText.length);

        // 如果已经是全部文本，结束循环
        if (testLength >= remainingText.length) {
          break;
        }
      }
      // 保存当前测试长度
      currentTestLength = testLength;

      // 确保在单词边界处切割（避免截断单词）
      let finalLength = testLength;
      if (testLength < remainingText.length) {
        // 向前查找最近的空格
        const lastSpaceIndex = remainingText
          .substring(0, testLength)
          .lastIndexOf(" ");
        if (lastSpaceIndex > 0) {
          finalLength = lastSpaceIndex + 1; // +1 to include the space
        }
      }

      // 取出当前可以放下的文本
      const currentSegment = remainingText.substring(0, finalLength);
      remainingText = remainingText.substring(finalLength);

      newElement.textContent = currentSegment;
    } else {
      // 如果是span节点，创建一个新的span
      span = document.createElement("span");

      // 获取原始span的所有属性并复制
      if (spanNode instanceof Element) {
        Array.from(spanNode.attributes).forEach((attr) => {
          span.setAttribute(attr.name, attr.value);
        });
      }

      let testLength = Math.min(segmentLength, remainingText.length);

      // 尝试增加文本长度，直到页面溢出
      while (testLength < remainingText.length) {
        const testText = remainingText.substring(0, testLength);
        span.textContent = testText;
        newElement.innerHTML = ""; // 清空之前的内容
        newElement.appendChild(span.cloneNode(true));

        testElement.innerHTML =
          GLOBAL_STYLE + updatedPageContent + newElement.outerHTML;
        pageContainer.innerHTML = testElement.innerHTML;

        if (pageContainer.clientHeight > pageHeight) {
          // 如果溢出，回退到上一个长度
          if (testLength > segmentLength) {
            testLength =
              testLength -
              Math.max(20, Math.floor((testLength - segmentLength) / 2));
          } else {
            // 即使最小分段也溢出，则取最小值
            testLength = Math.max(10, testLength - 10);
          }
          break;
        }

        // 增加测试长度
        testLength = Math.min(testLength + 50, remainingText.length);

        // 如果已经是全部文本，结束循环
        if (testLength >= remainingText.length) {
          break;
        }
      }
      // 保存当前测试长度
      currentTestLength = testLength;

      // 确保在单词边界处切割（避免截断单词）
      let finalLength = testLength;
      if (testLength < remainingText.length) {
        // 向前查找最近的空格
        const lastSpaceIndex = remainingText
          .substring(0, testLength)
          .lastIndexOf(" ");
        if (lastSpaceIndex > 0) {
          finalLength = lastSpaceIndex + 1; // +1 to include the space
        }
      }

      // 取出当前可以放下的文本
      const currentSegment = remainingText.substring(0, finalLength);
      remainingText = remainingText.substring(finalLength);

      // 重新创建span以确保干净
      span = document.createElement("span");
      if (spanNode instanceof Element) {
        Array.from(spanNode.attributes).forEach((attr) => {
          span.setAttribute(attr.name, attr.value);
        });
      }
      span.textContent = currentSegment;
      newElement.innerHTML = ""; // 确保元素是空的
      newElement.appendChild(span);
    }

    elements.push(newElement);

    // 更新当前页面内容，只有第一段需要保留原来页面的内容
    if (isFirstSegment) {
      updatedPageContent += newElement.outerHTML;
      isFirstSegment = false;
    } else {
      updatedPageContent = "";
    }

    // 动态调整分段长度
    segmentLength = currentTestLength;
  }

  return { elements, firstPageContent: updatedPageContent };
};

// 拆分包含多个图像或多个span的段落或标题
const splitParagraphWithImages = (
  paragraph: string,
  pageContainer?: HTMLDivElement,
  pageHeight?: number,
  currentPageContent?: string
): string[] => {
  // 如果段落不包含图像，且不需要处理span，则直接返回
  if (
    !paragraph.includes("<img") &&
    !paragraph.includes("<svg") &&
    !paragraph.includes("<image") &&
    (!pageContainer || !pageHeight || currentPageContent === undefined)
  ) {
    return [paragraph];
  }

  // 创建临时DOM元素来解析段落内容
  const tempPara = document.createElement("div");
  tempPara.innerHTML = paragraph;
  // 确定元素类型 (p, h1-h6)
  const firstChild = tempPara.firstChild;
  const nodeName = firstChild?.nodeName || "";
  const isPossiblyHeading = /^H[1-6]$/i.test(nodeName);
  // 使用原始标签类型或默认为p
  const tagName = isPossiblyHeading ? nodeName.toLowerCase() : "p";

  // 如果需要处理有多个span的段落
  if (pageContainer && pageHeight && currentPageContent !== undefined) {
    // 获取段落内所有的子节点（包括span, text, img等）
    const childNodes = Array.from(tempPara.firstChild?.childNodes || []);
    // 如果节点数量太少，不需要拆分
    if (childNodes.length <= 1) {
      return [paragraph];
    }

    // 处理段落中的span和其他元素
    const result: string[] = [];
    let currentElement = document.createElement(tagName);
    let currentPageContentCopy = currentPageContent;

    // 处理每个子节点
    for (let i = 0; i < childNodes.length; i++) {
      const childNode = childNodes[i];

      // 如果是图像节点，单独处理
      if (
        childNode.nodeName === "IMG" ||
        childNode.nodeName === "SVG" ||
        (childNode.nodeName === "IMAGE" &&
          childNode.parentNode?.nodeName !== "SVG")
      ) {
        // 如果当前元素中已有内容，先检查添加后是否会溢出
        if (currentElement.hasChildNodes()) {
          // 测试当前内容加上已有内容是否会溢出
          const testElement = document.createElement("div");
          testElement.innerHTML =
            GLOBAL_STYLE + currentPageContentCopy + currentElement.outerHTML;
          pageContainer.innerHTML = testElement.innerHTML;
          const testHeight = pageContainer.clientHeight;

          // 如果会溢出，先保存当前内容
          if (testHeight > pageHeight) {
            result.push(currentElement.outerHTML);
            currentPageContentCopy = "";
            currentElement = document.createElement(tagName);
          } else {
            result.push(currentElement.outerHTML);
            currentElement = document.createElement(tagName);
            currentPageContentCopy += result[result.length - 1];
          }
        }

        // 创建一个只包含图像的标签
        const imgContainer = document.createElement(tagName);
        imgContainer.appendChild(childNode.cloneNode(true));
        result.push(imgContainer.outerHTML);
        currentPageContentCopy = ""; // 图片后一律分页
      } else {
        // 添加当前节点到当前元素
        const tempElement = document.createElement(tagName);
        const clone = childNode.cloneNode(true);
        tempElement.appendChild(clone);

        // 测试添加此节点后是否会导致页面溢出
        const testElement = document.createElement("div");
        testElement.innerHTML =
          GLOBAL_STYLE +
          currentPageContentCopy +
          currentElement.outerHTML +
          tempElement.outerHTML;
        pageContainer.innerHTML = testElement.innerHTML;
        const testHeight = pageContainer.clientHeight;

        // 测试该节点单独在一个新页面是否会溢出
        const testNewPageElement = document.createElement("div");
        testNewPageElement.innerHTML = GLOBAL_STYLE + tempElement.outerHTML;
        pageContainer.innerHTML = testNewPageElement.innerHTML;
        const testNewPageHeight = pageContainer.clientHeight;

        // 如果添加到当前页会溢出
        if (testHeight > pageHeight) {
          // 先保存当前内容
          if (currentElement.hasChildNodes()) {
            result.push(currentElement.outerHTML);
          }

          // 如果节点本身也很大，即使单独放在一页也会溢出
          if (testNewPageHeight > pageHeight) {
            // 需要分割span内文字
            const splitResult = splitLargeSpanText(
              clone,
              tagName,
              pageContainer,
              pageHeight,
              ""
            );
            const elements = splitResult.elements;

            // 将分割后的元素添加到结果中
            for (let j = 0; j < elements.length; j++) {
              result.push(elements[j].outerHTML);
            }

            // 重置当前元素
            currentElement = document.createElement(tagName);
            currentPageContentCopy = "";
          } else {
            // 将节点添加到新页面
            currentElement = document.createElement(tagName);
            currentElement.appendChild(clone);
            currentPageContentCopy = "";
          }
        } else {
          // 如果不会溢出，正常添加
          currentElement.appendChild(clone);

          // 继续检查是否需要分页
          if (i < childNodes.length - 1) {
            // 不是最后一个节点才需要检查
            const testNextElement = document.createElement("div");
            testNextElement.innerHTML =
              GLOBAL_STYLE + currentPageContentCopy + currentElement.outerHTML;
            pageContainer.innerHTML = testNextElement.innerHTML;
            const testNextHeight = pageContainer.clientHeight;

            // 如果会溢出，保存当前内容并开始新元素
            if (testNextHeight > pageHeight) {
              result.push(currentElement.outerHTML);
              currentPageContentCopy = "";
              currentElement = document.createElement(tagName);
            }
          }
        }
      }
    }

    // 如果当前元素中还有内容，保存它
    if (currentElement.hasChildNodes()) {
      result.push(currentElement.outerHTML);
    }

    // 清空测试容器
    pageContainer.innerHTML = "";

    return result.length > 0 ? result : [paragraph];
  }

  // 处理图像分离的情况（原有逻辑）
  const result: string[] = [];
  let currentElement = document.createElement(tagName);
  let hasContent = false;

  // 处理段落中的所有子节点
  for (const childNode of Array.from(tempPara.firstChild?.childNodes || [])) {
    // 如果是图像节点
    if (
      childNode.nodeName === "IMG" ||
      childNode.nodeName === "SVG" ||
      (childNode.nodeName === "IMAGE" &&
        childNode.parentNode?.nodeName !== "SVG")
    ) {
      // 如果当前元素中已有内容，先保存它
      if (hasContent) {
        result.push(currentElement.outerHTML);
        currentElement = document.createElement(tagName);
        hasContent = false;
      }

      // 创建一个只包含图像的标签，使用原始标签类型
      const imgContainer = document.createElement(tagName);
      imgContainer.appendChild(childNode.cloneNode(true));
      result.push(imgContainer.outerHTML);
    } else {
      // 将非图像节点添加到当前元素
      currentElement.appendChild(childNode.cloneNode(true));
      hasContent = true;
    }
  }

  // 如果当前元素中还有内容，保存它
  if (hasContent) {
    result.push(currentElement.outerHTML);
  }

  return result.length > 0 ? result : [paragraph];
};

const resizeImgAndReturnInnerHTML = (
  paragraph: string,
  pageWidth: number,
  pageHeight: number
) => {
  // 创建临时容器来获取图片并处理图片尺寸
  const tempImgContainer = document.createElement("div");
  tempImgContainer.innerHTML = paragraph; // 设置最大尺寸限制
  const maxWidth = pageWidth * 0.9;
  const maxHeight = pageHeight * 0.9; // 为页面留出一些空间

  // 处理img标签图片大小
  const imgElements = tempImgContainer.querySelectorAll("img");
  if (imgElements.length > 0) {
    for (const img of imgElements) {
      // 设置图片样式，确保其不超出页面
      img.style.maxWidth = `${maxWidth}px`;
      img.style.maxHeight = `${maxHeight}px`;
      img.style.width = "auto"; // 保持纵横比
      img.style.height = "auto"; // 保持纵横比
      img.style.display = "block";
      img.style.margin = "1em auto"; // 居中显示
    }
  }

  // 处理SVG中的image标签
  const svgElements = tempImgContainer.querySelectorAll("svg");
  if (svgElements.length > 0) {
    for (const svg of svgElements) {
      // 获取SVG原始尺寸
      const svgWidth = parseFloat(svg.getAttribute("width") || "0");
      const svgHeight = parseFloat(svg.getAttribute("height") || "0");

      if (svgWidth > 0 && svgHeight > 0) {
        // 计算缩放比例
        const scale = Math.min(
          maxWidth / svgWidth,
          maxHeight / svgHeight,
          1 // 不放大，只缩小
        );

        // 设置新尺寸
        const newWidth = Math.floor(svgWidth * scale);
        const newHeight = Math.floor(svgHeight * scale);

        // 应用新尺寸
        svg.setAttribute("width", newWidth.toString());
        svg.setAttribute("height", newHeight.toString());
        svg.style.display = "block";
        svg.style.margin = "1em auto"; // 居中显示
      }

      // 处理SVG内部的image标签
      const imageElements = svg.querySelectorAll("image");
      for (const image of imageElements) {
        // 获取image标签的原始尺寸
        const imageWidth = parseFloat(image.getAttribute("width") || "0");
        const imageHeight = parseFloat(image.getAttribute("height") || "0");

        if (imageWidth > 0 && imageHeight > 0) {
          // 应用与SVG相同的缩放
          const scale = Math.min(
            maxWidth / imageWidth,
            maxHeight / imageHeight,
            1 // 不放大，只缩小
          );

          // 设置新尺寸
          const newWidth = Math.floor(imageWidth * scale);
          const newHeight = Math.floor(imageHeight * scale);

          // 应用新尺寸
          image.setAttribute("width", newWidth.toString());
          image.setAttribute("height", newHeight.toString());
        }
      }
    }
  }

  // 返回处理后的HTML内容
  return tempImgContainer.innerHTML;
};

// 处理单个元素并添加到页面中
const processElement = async (
  element: Element,
  pageContainer: HTMLDivElement,
  pageWidth: number,
  pageHeight: number,
  currentPageContent: string
): Promise<{ currentPageContent: string; newPages: string[] }> => {
  // 获取所有段落和标题
  const paragraphs = element.outerHTML.match(
    /<(p|h[1-6])[\s\S]*?<\/(p|h[1-6])>/g
  ) || [element.outerHTML];

  // 处理后产生的新页面
  const newPages: string[] = [];
  let updatedPageContent = currentPageContent;

  // 处理每个段落和标题
  for (const paragraph of paragraphs) {
    // 拆分包含多个图像或多个span的段落
    const splitParagraphs = splitParagraphWithImages(
      paragraph,
      pageContainer,
      pageHeight,
      updatedPageContent
    );

    // 处理拆分后的每个段落
    for (const singleParagraph of splitParagraphs) {
      // 检查是否包含'img'标签
      const isImage = singleParagraph.includes("<img");
      // 检查是否包含'svg'标签
      const isSvg = singleParagraph.includes("<svg");
      // 检查是否包含'image'标签
      const isImageTag = singleParagraph.includes("<image");

      // 定义一个paragraph用于存储当前段落的内容
      let resultParagraph = singleParagraph;

      // 是否包含图片 进行图片大小处理
      if (
        (isImage || isSvg || isImageTag) &&
        updatedPageContent.trim() !== ""
      ) {
        // 替换原始段落为处理过尺寸的段落
        resultParagraph = resizeImgAndReturnInnerHTML(
          singleParagraph,
          pageWidth,
          pageHeight
        );
      }

      // 计算加了GLOBAL_STYLE样式后的页面的高度
      pageContainer.innerHTML =
        GLOBAL_STYLE + updatedPageContent + resultParagraph;
      const currentHeight = pageContainer.clientHeight;

      // 如果当前高度超过页面高度，强制分页
      if (currentHeight > pageHeight) {
        newPages.push(GLOBAL_STYLE + updatedPageContent);
        updatedPageContent = resultParagraph; // 将当前段落放到新页面
      } else {
        // 如果当前高度未超过页面高度，继续添加
        updatedPageContent += resultParagraph;
      }
    }
  }
  pageContainer.innerHTML = "";
  return { currentPageContent: updatedPageContent, newPages };
};

// 分割内容到左右栏
const splitContentForTwoColumns = async (html: string) => {
  // 存储所有页面的内容
  const tempDiv = document.createElement("div");
  tempDiv.innerHTML = html;
  const elements = Array.from(tempDiv.children);

  // 得到页面宽度和高度
  const pageHeight = window.innerHeight * 0.9;
  const pageWidth = window.innerWidth / 2;

  // 初始化当前页面的内容
  let currentPageContent = "";
  allPages.value = [];

  const pageContainer = document.createElement("div");
  pageContainer.style.width = `${pageWidth}px`;
  pageContainer.style.padding = `${PAGE_PADDING}px`;
  pageContainer.style.overflow = "hidden";
  pageContainer.style.position = "relative";
  pageContainer.style.boxSizing = "border-box";
  document.body.appendChild(pageContainer);

  for (const element of elements) {
    const result = await processElement(
      element,
      pageContainer,
      pageWidth,
      pageHeight,
      currentPageContent
    );

    // 添加新的页面到总页面集合
    allPages.value.push(...result.newPages);
    // 更新当前页面内容
    currentPageContent = result.currentPageContent;
  }

  if (currentPageContent) {
    allPages.value.push(GLOBAL_STYLE + currentPageContent);
  }
  document.body.removeChild(pageContainer);
  totalPages.value = allPages.value.length;
  updateVisiblePages();
};

// 更新当前可见的页面
const updateVisiblePages = () => {
  // 确保页码有效
  if (currentPage.value < 0) {
    currentPage.value = 0;
  }

  if (currentPage.value >= totalPages.value - 1) {
    currentPage.value = Math.max(0, totalPages.value - 2);
  }

  // 如果是奇数页，确保当前页是偶数（左页显示偶数页，右页显示奇数页）
  if (currentPage.value % 2 !== 0) {
    currentPage.value = Math.max(0, currentPage.value - 1);
  }

  // 设置左右页面内容
  leftColumnContent.value = allPages.value[currentPage.value] || "";
  rightColumnContent.value = allPages.value[currentPage.value + 1] || "";
};

// 翻页方法
const goToNextPage = () => {
  if (currentPage.value + 2 < totalPages.value) {
    currentPage.value += 2;
    updateVisiblePages();
  }
};

const goToPreviousPage = () => {
  if (currentPage.value > 0) {
    currentPage.value -= 2;
    updateVisiblePages();
  }
};

// Add window control functions
const minimizeWindow = async () => {
  await appWindow.minimize();
};

const maximizeWindow = async () => {
  if (await appWindow.isMaximized()) {
    await appWindow.unmaximize();
  } else {
    await appWindow.maximize();
  }
};

const closeWindow = async () => {
  await appWindow.close();
};
</script>

<template>
  <div class="reader-container">
    <!-- Toolbar -->
    <div class="reader-toolbar">
      <div class="left-controls">
        <button class="icon-button" @click="goBackToMenu" title="返回书架">
          <el-icon :size="20"><ArrowLeft /></el-icon>
        </button>
        <el-dropdown trigger="click">
          <button class="icon-button" title="设置">
            <el-icon :size="20"><Setting /></el-icon>
          </button>
          <template #dropdown>
            <el-dropdown-menu slot="dropdown">
              <el-dropdown-item @click="goBackToMenu">选项一</el-dropdown-item>
              <el-dropdown-item @click="goBackToMenu">选项二</el-dropdown-item>
              <el-dropdown-item @click="handleWindowResize"
                >重新加载</el-dropdown-item
              >
            </el-dropdown-menu>
          </template>
        </el-dropdown>
      </div>
      <div class="page-indicator-inline" v-if="currentContent">
        {{ currentPage + 1 }} : {{ Math.min(currentPage + 2, totalPages) }} ·
        {{ totalPages }}
      </div>
      <div class="window-controls">
        <button
          class="window-control-button"
          @click="minimizeWindow"
          title="Minimize"
        >
          <el-icon :size="16"><Minus /></el-icon>
        </button>
        <button
          class="window-control-button"
          @click="maximizeWindow"
          title="Maximize"
        >
          <el-icon :size="16"><FullScreen /></el-icon>
        </button>
        <button
          class="window-control-button close-button"
          @click="closeWindow"
          title="Close"
        >
          <el-icon :size="16"><Close /></el-icon>
        </button>
      </div>
    </div>

    <!-- Placeholder -->
    <div v-if="!currentContent" class="placeholder">
      <div class="instruction">正在准备电子书内容...</div>
    </div>
    <!-- HTML Viewer - 书籍双页式布局 -->
    <div v-if="currentContent" class="html-view-container">
      <div class="resize-hint" v-if="resizeTimeout !== null">
        <div class="hint-text">重新布局内容中...</div>
      </div>

      <div class="two-column-layout">
        <!-- 专门用于捕获onWheel事件的绝对定位透明div -->
        <div
          style="
            position: absolute;
            inset: 0;
            z-index: 10;
            background: transparent;
          "
          @wheel="onWheel"
        ></div>

        <button
          class="page-button-side prev-button-side"
          @click="goToPreviousPage"
          :disabled="currentPage <= 0"
          title="上一页"
        >
          <el-icon :size="16">
            <ArrowLeft />
          </el-icon>
        </button>

        <div class="column left-column">
          <iframe
            :srcdoc="leftColumnContent"
            class="html-iframe"
            frameborder="0"
          ></iframe>
        </div>
        <div class="column right-column">
          <iframe
            :srcdoc="rightColumnContent"
            class="html-iframe"
            frameborder="0"
          ></iframe>
        </div>
        <button
          class="page-button-side next-button-side"
          @click="goToNextPage"
          :disabled="currentPage + 2 >= totalPages"
          title="下一页"
        >
          <el-icon :size="16">
            <ArrowRight />
          </el-icon>
        </button>
      </div>
    </div>
  </div>
</template>

<style scoped src="./ReaderView.css" />
